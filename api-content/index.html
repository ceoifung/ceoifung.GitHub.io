{"posts":[{"title":"Linux系统软件更新的一种设计思路","content":"前言 在Linux系统下开发软件存在一个更新的难题，一般来说，解决方法有如下几种方案： 将软件上传到ubuntu的APT仓库，取得官方的资格认可，然后使用sudo apt-get install 软件名称来下载安装以及更新 自行搭建APT仓库，在安装软件之前将自己的APT仓库源添加到系统中，此方法需要很精通Linux的一些操作指令，而且搭建方法也较为复杂，对于一般的新手来说比较艰难 使用脚本更新，通过脚本的方式，拉取远端服务器上的脚本资源实现一键更新 经过测试，发现脚本更新的方式最为简单，而且自由度高，因此本文将针对脚本更新的方式进行一个大致的说明教程 脚本更新方式描述 要想做到脚本更新的方式，需要遵循如下几个步骤： 编写远程更新脚本 在远端服务器存储软件包 通过Linux的curl指令拉取远端的服务器脚本，并执行 远程更新脚本编写 远程脚本更新需要包含如下几个内容，比如是否需要传参，固件的下载地址等，下面以软件更新脚本install.sh作为一个简单的说明： #! /bin/sh set -e case $1 in &quot;roboticmaster&quot;) myurl=&quot;https://github.com/XiaoRGEEK/OpenRoboticMaster/releases/download/v0.0.3/roboticmaster-amd64.deb&quot; ;; &quot;roboticmaster-zh&quot;) myurl=&quot;https://gitee.com/xiaorgeek/open-robotic-master/attach_files/803287/download/roboticmaster-amd64.deb&quot; ;; &quot;xrosmanager&quot;) myurl=&quot;https://github.com/XiaoRGEEK/OpenXROSManager/releases/download/v1.3.4/xrosmanager-arm64.deb&quot; ;; &quot;xrosmanager-zh&quot;) myurl=&quot;https://gitee.com/xiaorgeek/open-xrosmanager/attach_files/807025/download/xrosmanager-arm64.deb&quot; ;; &quot;xrosmanager-pi&quot;) myurl=&quot;https://github.com/XiaoRGEEK/OpenXROSManagerRaspberry/releases/download/v1.3.4/xrosmanager-raspberry-arm64.deb&quot; ;; &quot;xrosmanager-pi-zh&quot;) myurl=&quot;https://gitee.com/xiaorgeek/open-xrosmanager-raspberry-pi/attach_files/819388/download/xrosmanager-raspberry-arm64.deb&quot; ;; *) echo -e &quot;\\033[31mMissing or incorrect parameters, at least one parameter required such as xrosmanager\\033[0m&quot; exit 1 ;; esac echo -e &quot;\\033[35mDownloading...\\033[0m&quot; wget $myurl -O xrpackage.deb if [ ! $? -eq 0 ] then echo -e &quot;\\033[31m download failed, Check the network \\033[0m&quot; rm -rf xrpackage.deb exit 1 fi echo -e &quot;\\033[35mUpgrade package ready, start updating...\\033[0m&quot; sudo dpkg -i xrpackage.deb if [ ! $? -eq 0 ] then echo -e &quot;\\033[31mInstallation failed, please check your system environment\\033[0m&quot; rm -rf xrpackage.deb exit 1 fi rm -rf xrpackage.deb 如上方的更新脚本，case关键字代表判断传入的参数$1，如果存在多个软件更新内容的话可以使用这种判断方式，根据不同的参数设置不同的url，即软件下载地址。紧接着使用wget $myurl -O xrpackage.deb这一条指令拉取需要下载的软件，最后判断指令执行情况，根据需要编写自己的脚本。 注意：上述脚本需要放置在服务器 在远端服务器存储软件包 我们最终实现的目的是远程的服务器的软件拉取到本地，首先我们就要存储软件到服务器上。这里选择的是将软件打包之后，存储到gitee和github上，因为这两个网站是免费的，而且方便我们进行相应的版本更新。当然，如果说有自己的需求的话，可以自行购买服务器存储，到时候连接过去就行。 curl 脚本编写 以上步骤准备完毕之后，可以进行一个curl的脚本编写，将该脚本提供给相应的用户，让他运行该指令即可，在本次实例中，更新脚本最终的写法如下： curl -s http://xxx.com/install.sh | bash -s &lt;软件名称&gt; 如果不想暴露更新接口给到用户，可以写成相应的脚本形式，让用户直接运行脚本即可 ","link":"https://ceoifung.github.io/post/linux-software-update/"},{"title":"MySQL的一些常用操作","content":"解除MySQL远程连接 新建数据库用户 如下指令为新建MySQL用户，赋予只能对ubtsn_db数据库进行select,insert,update,delete,drop,create操作，该操作主要针对公司远端服务器，保护数据安全 grant select,insert,update,delete,drop,create on ubtsn_db.* to ceoifung@&quot;%&quot; identified by &quot;xiaorgeek001?&quot;; 赋予用户对该表操作的所有权限 grant all privileges on ubtsn_db.* to ceoifung@&quot;%&quot; identified by &quot;xiaorgeek001?&quot;; ","link":"https://ceoifung.github.io/post/mysql-operation/"},{"title":"android检测用户是否使用代理上网","content":" 在一些网络需求中，为了防止用户抓包，往往采用检测用户当前网络是不是VPN上网的手段。但是依照国内网上的写法，测试中发现根本就没有用。所以经过一段时间的查询之后，找到了解决方法。 以往的写法 /* * * 判断设备 是否使用代理上网 */ private boolean isWifiProxy(Context context) { final boolean IS_ICS_OR_LATER = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH; String proxyAddress; int proxyPort; if (IS_ICS_OR_LATER) { proxyAddress = System.getProperty(&quot;http.proxyHost&quot;); String portStr = System.getProperty(&quot;http.proxyPort&quot;); proxyPort = Integer.parseInt((portStr != null ? portStr : &quot;-1&quot;)); } else { proxyAddress = android.net.Proxy.getHost(context); proxyPort = android.net.Proxy.getPort(context); } return (!TextUtils.isEmpty(proxyAddress)) &amp;&amp; (proxyPort != -1); } 现在的新写法 注意：使用该写法容易产生一刀切的问题，但是目前没有找到很好的解决方案，因此只能将就用一下 /** * 检测用户是否使用VPN代理上网抓包 * @param context 上下文 * @return vpn使用结果 */ public static boolean isVpnProxy(final Context context) { ConnectivityManager connMgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); boolean isVpnConn = false; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { for (Network network : connMgr.getAllNetworks()) { NetworkInfo networkInfo = connMgr.getNetworkInfo(network); if (networkInfo.getType() == ConnectivityManager.TYPE_VPN) { isVpnConn |= networkInfo.isConnected(); } } } return isVpnConn; } ","link":"https://ceoifung.github.io/post/android-check-proxy/"},{"title":"linux 安装nodejs方法","content":"下载nodejs压缩包 在nodejs官方网站download页面中选择需要使用的版本,可以选择LTS或current,选择对应系统右键复制链接地址https://nodejs.org/dist/v14.17.5/ 选择合适版本的软件，然后将软件下载到本地，再通过ssh工具将软件上传到ubuntu系统中 解压 tar -xvf node-v14.17.5-linux-x64.tar.xz 配置软连接 sudo ln /home/ubuntu/node-v14.17.5-linux-x64/bin/node /usr/local/bin/node sudo ln /home/ubuntu/node-v14.17.5-linux-x64/bin/npm /usr/local/bin/npm 配置完毕之后，可以查看一下是否安装成功 node -v npm -v ","link":"https://ceoifung.github.io/post/install_nodejs/"},{"title":"Debian系统打包deb程序教程","content":"1. 适用环境 本教程适用于Debian系的系统，比如Debian、Ubuntu等。 2. 程序打包教程 2.1 新建打包目录 # 在/home/用户名目录下新建工作目录 mkdir work work/build cd work/build # 在work目录下新建打包的软件目录 mkdir osmanager osmanager/DEBIAN osmanager/usr/bin osmanager/usr/share/applications osmanager/usr/share/icons -p # 新建配置control文件 touch osmanager/DEBIAN/control 运行以上指令之后，最终生成如下文件目录结构 pi@raspberry:~/work/build/osmanager $ tree . ├── DEBIAN └── usr ├── bin └── share ├── applications └── icons 6 directories, 0 files 2.2 打包目录结构解析 DEBIAN：必须大写，用来进行制作打包文件，描述相关的打包信息 control：描述deb包的信息必须的文件 usr：用户安装文件一般会存到这个文件下，安装后的一些配置文件，可执行文件等可能会存放到usr下不同的目录下 usr/share：共享文件夹 usr/share/applications：应用的配置信息，Ubuntu启动时会找到applications下的.desktop文件将其加载到应用中，如果需要生成桌面可执行程序的时候，可以编写相应的desktop文件，否则。可以留空 usr/share/icons：这是存放软件logo的地方，安装后图标文件会生成到/usr/share/icons/ /usr/bin：这个是最重要的部分，存放可执行程序。由于我build之后的项目是一个文件夹，里面不单单存在可执行文件，还有其他依赖文件，所以需要都放到该目录下，可以直接将build/linuxxxx 文件下的内容copy到lib中 2.3 定义control 文件 package: XROSManager version: 1.0.0 architecture: arm64 maintainer: Shenzhen XiaoRGEEK Technology Co., Ltd description: XiaoRGEEK OS Manager, Copyright (c) 2021, Powered by Ceoifung. 相关字段解析如下： package: 打包后的程序包名 version: 软件包的版本 architecture：打包适配的系统架构。这边由于选择的打包平台为jetson nano，所以CPU架构是arm64。如果不知道自己系统的CPU架构的话，可以使用如下指令进行查询： # 以下是在树莓派PC端系统上输入的查询指令，可以清晰的看到树莓派的系统版本是amd64 pi@raspberry:~ $ uname -a Linux raspberry 4.19.0-13-amd64 #1 SMP Debian 4.19.160-2 (2020-11-28) x86_64 GNU/Linux maintainer：生产厂商以及维护者 description：软件的描述信息 2.4 复制程序到usr/bin目录 由于我打包之后的是一整个文件夹XROSManager-linux-arm64，文件夹内容如下： pi@raspberry:~/work/build/XROSManager-linux-x64 $ tree . ├── blink_image_resources_200_percent.pak ├── content_resources_200_percent.pak ├── content_shell.pak ├── icudtl.dat ├── libffmpeg.so ├── libnode.so ├── LICENSE ├── LICENSES.chromium.html ├── locales ├── natives_blob.bin ├── pdf_viewer_resources.pak ├── resources │ ├── app.asar │ ├── conf.ini │ └── electron.asar ├── snapshot_blob.bin ├── ui_resources_200_percent.pak ├── version ├── views_resources_200_percent.pak └── XROSManager 将文件夹的所有内容复制到osmanager/usr/bin目录下 cp -r ./XROSManager-linux-arm64/* ./osmanager/usr/bin/ 2.4 定义deb.desktop文件 由于所选实例是需要在桌面生成可执行快捷方式，因此在我定义了desktop文件。如果是不需要生成桌面快捷方式的，可以忽略本节内容。 [Desktop Entry] Name=XROSManager Comment=XiaoRGEEK OS Manager Exec=/usr/bin/XROSManager Icon=/usr/share/icons/icon.png Terminal=false Type=Application X-Ubuntu-Touch=true Categories=Development 2.5 打包deb包 将目录切换回build的目录下 pi@raspberry:~/work/build $ ls -l total 12 drwxr-xr-x 2 pi pi 4096 May 8 09:49 icons drwxr-xr-x 4 pi pi 4096 May 13 09:54 osmanager drwxr-xr-x 4 pi pi 4096 May 13 09:46 XROSManager-linux-arm64 运行如下打包命令 sudo dpkg -b osmanager xrosmanager-arm64.deb 命令执行成功之后，会在build目录下生成xrosmanager-arm64.deb包，使用如下命令可以快速安装 sudo dpkg -i xrosmanager-arm64.deb 安装完毕之后，可以在终端输入程序包名，运行程序，比如我的可执行程序为XROSManager。那么直接运行即可 XROSManager 同时可以在/usr/bin目录下查看到安装后的程序，另外打开应用列表，可以查看到我们新安装的软件（前提是有配置desktop文件）。 2.6 写成脚本形式运行 打包脚本 vim make.sh # 给脚本权限 chmod 777 make.sh # 运行脚本 ./make.sh 脚本详细内容 #! /bin/sh cat ./build/banner.txt echo -e &quot;\\033[35m开始编译程序...\\033[0m&quot; npm run build:linux echo -e &quot;\\033[35m程序编译完毕，正在复制文件...\\033[0m&quot; cp -f -r ./build/XROSManager-linux-arm64/* ./build/osmanager/usr/bin/ cp ./build/icons/256x256.png ./build/osmanager/usr/share/icons/icon.png echo -e &quot;\\033[35m文件复制完毕，开始打包...\\033[0m&quot; sudo dpkg -b ./build/osmanager ./build/xrosmanager-arm64.deb echo -e &quot;\\033[35m打包完成，可以运行如下指令进行安装\\033[0m\\n\\n\\033[33msudo dpkg -i ./build/xrosmanager-arm64.deb \\033[0m \\n\\n\\033[44;37mAll done, thank you.\\033[0m\\n&quot; 注意：以上脚本请对应地进行酌量的修改，工程不同，内容也就不一致。 安装脚本 vim install.sh # 给脚本权限 chmod 777 install.sh # 运行脚本 ./install.sh 脚本详细内容 #! /bin/sh # 如果软件有相关的依赖需要安装的话 echo -e &quot;\\033[35m开始安装依赖(需要联网以及sudo权限)...\\033[0m&quot; sudo apt -y install libgconf2-4 echo -e &quot;\\033[35m依赖安装完毕，开始安装软件...\\033[0m&quot; sudo dpkg -i xrosmanager-arm64.deb echo -e &quot;\\033[35m安装成功，可以运行如下指令运行程序(不可在ssh中运行)\\033[0m\\n\\n\\033[33mXROSManager \\033[0m \\n\\n\\033[35m卸载程序请运行\\033[0m\\n\\n\\033[33msudo dpkg -r XROSManager \\033[0m \\n\\n\\033[44;37mAll done, thank you.\\033[0m\\n&quot; 3. 说在后面 本教程的实例来源于某一工程，用户需要根据自己的工程，进行相应的修改。 ","link":"https://ceoifung.github.io/post/deb-pack/"}]}