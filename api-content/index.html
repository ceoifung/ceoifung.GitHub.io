{"posts":[{"title":"android检测用户是否使用代理上网","content":" 在一些网络需求中，为了防止用户抓包，往往采用检测用户当前网络是不是VPN上网的手段。但是依照国内网上的写法，测试中发现根本就没有用。所以经过一段时间的查询之后，找到了解决方法。 以往的写法 /* * * 判断设备 是否使用代理上网 */ private boolean isWifiProxy(Context context) { final boolean IS_ICS_OR_LATER = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH; String proxyAddress; int proxyPort; if (IS_ICS_OR_LATER) { proxyAddress = System.getProperty(&quot;http.proxyHost&quot;); String portStr = System.getProperty(&quot;http.proxyPort&quot;); proxyPort = Integer.parseInt((portStr != null ? portStr : &quot;-1&quot;)); } else { proxyAddress = android.net.Proxy.getHost(context); proxyPort = android.net.Proxy.getPort(context); } return (!TextUtils.isEmpty(proxyAddress)) &amp;&amp; (proxyPort != -1); } 现在的新写法 注意：使用该写法容易产生一刀切的问题，但是目前没有找到很好的解决方案，因此只能将就用一下 /** * 检测用户是否使用VPN代理上网抓包 * @param context 上下文 * @return vpn使用结果 */ public static boolean isVpnProxy(final Context context) { ConnectivityManager connMgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); boolean isVpnConn = false; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { for (Network network : connMgr.getAllNetworks()) { NetworkInfo networkInfo = connMgr.getNetworkInfo(network); if (networkInfo.getType() == ConnectivityManager.TYPE_VPN) { isVpnConn |= networkInfo.isConnected(); } } } return isVpnConn; } ","link":"https://ceoifung.github.io/post/android-check-proxy/"},{"title":"linux 安装nodejs方法","content":"下载nodejs压缩包 在nodejs官方网站download页面中选择需要使用的版本,可以选择LTS或current,选择对应系统右键复制链接地址https://nodejs.org/dist/v14.17.5/ 选择合适版本的软件，然后将软件下载到本地，再通过ssh工具将软件上传到ubuntu系统中 解压 tar -xvf node-v14.17.5-linux-x64.tar.xz 配置软连接 sudo ln /home/ubuntu/node-v14.17.5-linux-x64/bin/node /usr/local/bin/node sudo ln /home/ubuntu/node-v14.17.5-linux-x64/bin/npm /usr/local/bin/npm 配置完毕之后，可以查看一下是否安装成功 node -v npm -v ","link":"https://ceoifung.github.io/post/install_nodejs/"},{"title":"Debian系统打包deb程序教程","content":"1. 适用环境 本教程适用于Debian系的系统，比如Debian、Ubuntu等。 2. 程序打包教程 2.1 新建打包目录 # 在/home/用户名目录下新建工作目录 mkdir work work/build cd work/build # 在work目录下新建打包的软件目录 mkdir osmanager osmanager/DEBIAN osmanager/usr/bin osmanager/usr/share/applications osmanager/usr/share/icons -p # 新建配置control文件 touch osmanager/DEBIAN/control 运行以上指令之后，最终生成如下文件目录结构 pi@raspberry:~/work/build/osmanager $ tree . ├── DEBIAN └── usr ├── bin └── share ├── applications └── icons 6 directories, 0 files 2.2 打包目录结构解析 DEBIAN：必须大写，用来进行制作打包文件，描述相关的打包信息 control：描述deb包的信息必须的文件 usr：用户安装文件一般会存到这个文件下，安装后的一些配置文件，可执行文件等可能会存放到usr下不同的目录下 usr/share：共享文件夹 usr/share/applications：应用的配置信息，Ubuntu启动时会找到applications下的.desktop文件将其加载到应用中，如果需要生成桌面可执行程序的时候，可以编写相应的desktop文件，否则。可以留空 usr/share/icons：这是存放软件logo的地方，安装后图标文件会生成到/usr/share/icons/ /usr/bin：这个是最重要的部分，存放可执行程序。由于我build之后的项目是一个文件夹，里面不单单存在可执行文件，还有其他依赖文件，所以需要都放到该目录下，可以直接将build/linuxxxx 文件下的内容copy到lib中 2.3 定义control 文件 package: XROSManager version: 1.0.0 architecture: arm64 maintainer: Shenzhen XiaoRGEEK Technology Co., Ltd description: XiaoRGEEK OS Manager, Copyright (c) 2021, Powered by Ceoifung. 相关字段解析如下： package: 打包后的程序包名 version: 软件包的版本 architecture：打包适配的系统架构。这边由于选择的打包平台为jetson nano，所以CPU架构是arm64。如果不知道自己系统的CPU架构的话，可以使用如下指令进行查询： # 以下是在树莓派PC端系统上输入的查询指令，可以清晰的看到树莓派的系统版本是amd64 pi@raspberry:~ $ uname -a Linux raspberry 4.19.0-13-amd64 #1 SMP Debian 4.19.160-2 (2020-11-28) x86_64 GNU/Linux maintainer：生产厂商以及维护者 description：软件的描述信息 2.4 复制程序到usr/bin目录 由于我打包之后的是一整个文件夹XROSManager-linux-arm64，文件夹内容如下： pi@raspberry:~/work/build/XROSManager-linux-x64 $ tree . ├── blink_image_resources_200_percent.pak ├── content_resources_200_percent.pak ├── content_shell.pak ├── icudtl.dat ├── libffmpeg.so ├── libnode.so ├── LICENSE ├── LICENSES.chromium.html ├── locales ├── natives_blob.bin ├── pdf_viewer_resources.pak ├── resources │ ├── app.asar │ ├── conf.ini │ └── electron.asar ├── snapshot_blob.bin ├── ui_resources_200_percent.pak ├── version ├── views_resources_200_percent.pak └── XROSManager 将文件夹的所有内容复制到osmanager/usr/bin目录下 cp -r ./XROSManager-linux-arm64/* ./osmanager/usr/bin/ 2.4 定义deb.desktop文件 由于所选实例是需要在桌面生成可执行快捷方式，因此在我定义了desktop文件。如果是不需要生成桌面快捷方式的，可以忽略本节内容。 [Desktop Entry] Name=XROSManager Comment=XiaoRGEEK OS Manager Exec=/usr/bin/XROSManager Icon=/usr/share/icons/icon.png Terminal=false Type=Application X-Ubuntu-Touch=true Categories=Development 2.5 打包deb包 将目录切换回build的目录下 pi@raspberry:~/work/build $ ls -l total 12 drwxr-xr-x 2 pi pi 4096 May 8 09:49 icons drwxr-xr-x 4 pi pi 4096 May 13 09:54 osmanager drwxr-xr-x 4 pi pi 4096 May 13 09:46 XROSManager-linux-arm64 运行如下打包命令 sudo dpkg -b osmanager xrosmanager-arm64.deb 命令执行成功之后，会在build目录下生成xrosmanager-arm64.deb包，使用如下命令可以快速安装 sudo dpkg -i xrosmanager-arm64.deb 安装完毕之后，可以在终端输入程序包名，运行程序，比如我的可执行程序为XROSManager。那么直接运行即可 XROSManager 同时可以在/usr/bin目录下查看到安装后的程序，另外打开应用列表，可以查看到我们新安装的软件（前提是有配置desktop文件）。 2.6 写成脚本形式运行 打包脚本 vim make.sh # 给脚本权限 chmod 777 make.sh # 运行脚本 ./make.sh 脚本详细内容 #! /bin/sh cat ./build/banner.txt echo -e &quot;\\033[35m开始编译程序...\\033[0m&quot; npm run build:linux echo -e &quot;\\033[35m程序编译完毕，正在复制文件...\\033[0m&quot; cp -f -r ./build/XROSManager-linux-arm64/* ./build/osmanager/usr/bin/ cp ./build/icons/256x256.png ./build/osmanager/usr/share/icons/icon.png echo -e &quot;\\033[35m文件复制完毕，开始打包...\\033[0m&quot; sudo dpkg -b ./build/osmanager ./build/xrosmanager-arm64.deb echo -e &quot;\\033[35m打包完成，可以运行如下指令进行安装\\033[0m\\n\\n\\033[33msudo dpkg -i ./build/xrosmanager-arm64.deb \\033[0m \\n\\n\\033[44;37mAll done, thank you.\\033[0m\\n&quot; 注意：以上脚本请对应地进行酌量的修改，工程不同，内容也就不一致。 安装脚本 vim install.sh # 给脚本权限 chmod 777 install.sh # 运行脚本 ./install.sh 脚本详细内容 #! /bin/sh # 如果软件有相关的依赖需要安装的话 echo -e &quot;\\033[35m开始安装依赖(需要联网以及sudo权限)...\\033[0m&quot; sudo apt -y install libgconf2-4 echo -e &quot;\\033[35m依赖安装完毕，开始安装软件...\\033[0m&quot; sudo dpkg -i xrosmanager-arm64.deb echo -e &quot;\\033[35m安装成功，可以运行如下指令运行程序(不可在ssh中运行)\\033[0m\\n\\n\\033[33mXROSManager \\033[0m \\n\\n\\033[35m卸载程序请运行\\033[0m\\n\\n\\033[33msudo dpkg -r XROSManager \\033[0m \\n\\n\\033[44;37mAll done, thank you.\\033[0m\\n&quot; 3. 说在后面 本教程的实例来源于某一工程，用户需要根据自己的工程，进行相应的修改。 ","link":"https://ceoifung.github.io/post/deb-pack/"}]}