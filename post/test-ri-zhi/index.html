<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>test日志 | Gridea</title>
<link rel="shortcut icon" href="https://ceoifung.github.io/rosdoc//favicon.ico?v=1629788908476">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://ceoifung.github.io/rosdoc//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="test日志 | Gridea - Atom Feed" href="https://ceoifung.github.io/rosdoc//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="[TOC]
海风机器人教程

该课程需要扩展支持，扩展地址：https://github.com/XiaoRGEEK/xrkoi

前言
本机器人需要制作如下卡片：

图形识别： 矩形以及圆形
智慧出行实验：红色、绿色以及黄色三张卡片
物体..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://ceoifung.github.io/rosdoc/">
  <img class="avatar" src="https://ceoifung.github.io/rosdoc//images/avatar.png?v=1629788908476" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/ceoifung" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              test日志
            </h2>
            <div class="post-info">
              <span>
                2021-08-24
              </span>
              <span>
                36 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>[TOC]</p>
<h1 id="海风机器人教程">海风机器人教程</h1>
<blockquote>
<p>该课程需要扩展支持，扩展地址：https://github.com/XiaoRGEEK/xrkoi</p>
</blockquote>
<h2 id="前言">前言</h2>
<p>本机器人需要制作如下卡片：</p>
<ul>
<li>图形识别： 矩形以及圆形</li>
<li>智慧出行实验：红色、绿色以及黄色三张卡片</li>
<li>物体分类器实验：需要10张自定义的物体卡片，此10张物体卡片需要与提供的默认模型相匹配</li>
<li>视觉巡线实验：视觉巡线模组卡片三张，分别是直线，左转以及右转</li>
</ul>
<p>本机器人引脚说明：</p>
<ul>
<li>通信引脚：microbit与K210以及底板通讯采用串口，引脚定义为：<strong>Tx: pin1，Rx: pin2</strong></li>
<li>超声波通信引脚：<strong>Trig：pin13，Echo：pin14</strong></li>
<li>RGB灯带：<strong>pin16</strong></li>
<li>红外传感器检测引脚：<strong>pin8</strong></li>
</ul>
<h2 id="第一章-microbit机器人概述">第一章 Microbit机器人概述</h2>
<p>略</p>
<h2 id="第二章-机器人控制实验">第二章 机器人控制实验</h2>
<p>目的： 通过microbit自带的两个按钮控制机器人进行运动</p>
<p>操作：按下按钮A控制机器人前进，按下按钮B控制机器人后退，按钮A+B同时按下机器人停止</p>
<p>代码：</p>
<pre><code class="language-python"># 按钮A按下机器人前进
def on_button_pressed_a():
    serial.write_buffer(CMD_FORWARD)
input.on_button_pressed(Button.A, on_button_pressed_a)

# 按钮B按下机器人后退
def on_button_pressed_b():
    serial.write_buffer(CMD_BACKWARD)
input.on_button_pressed(Button.B, on_button_pressed_b)

# 按钮AB同时按下机器人停止
def on_button_pressed_ab():
    serial.write_buffer(CMD_STOP)
input.on_button_pressed(Button.AB, on_button_pressed_ab)

# 初始化命令控制变量
CMD_FORWARD = Buffer.from_array([0xff, 0x02, 0x06, 0x00])
CMD_BACKWARD = Buffer.from_array([0xff, 0x02, 0x07, 0x00])
CMD_STOP = Buffer.from_array([0xff, 0x02, 0x0a, 0x00])
basic.show_icon(IconNames.HAPPY)
# 重定向串口
serial.redirect(SerialPin.P1, SerialPin.P2, BaudRate.BAUD_RATE115200)
</code></pre>
<h2 id="第三章-红外遥控实验">第三章 红外遥控实验</h2>
<p>目的：按下红外遥控器的2、4、5、6、8键可以控制机器人分别做出前进、左转、停止、右转以及后退的操作</p>
<p>原理：红外接收器接在核心板上，因此我们需要通过相关指令去查询红外接收按键的按下情况，具体的键值以及回传内容请查看相关的通信协议。同时为了更加清晰的说明获取的步骤以及通信协议的解析，我们单独提供了一个简易版本的程序，同时我们提供了已经封装好的函数，用户直接调用即可。这两种方法任君选择</p>
<p>操作：按下按钮A开始检测红外遥控器的按下情况，按下按钮B停止检测红外遥控器</p>
<p>代码：</p>
<p><strong>控制机器人运动</strong></p>
<pre><code class="language-python">&quot;&quot;&quot;
按下按钮A使能红外遥控器
按下红外遥控器2,4,6,8,5控制机器人运动
按下按钮B取消使能红外遥控器
&quot;&quot;&quot;
data: Buffer = None

# 控制指令
CMD_FORWARD = Buffer.from_array([0xff, 0x02, 0x06, 0x00])
CMD_BACKWARD = Buffer.from_array([0xff, 0x02, 0x07, 0x00])
CMD_LEFT = Buffer.from_array([0xff, 0x02, 0x08, 0x00])
CMD_RIGHT = Buffer.from_array([0xff, 0x02, 0x09, 0x00])
CMD_STOP = Buffer.from_array([0xff, 0x02, 0x0a, 0x00])
# 红外遥控器键值读取
CMD_START_IR = Buffer.from_array([0xff, 0x01, 0x03, 0x01])
CMD_STOP_IR = Buffer.from_array([0xff, 0x01, 0x03,0x00])
# 重定向串口
serial.redirect(SerialPin.P1, SerialPin.P2, BaudRate.BAUD_RATE115200)
# 设置开机microbit点阵显示图案
basic.show_icon(IconNames.HAPPY)

# 功能选择器
def switcher(cmd):
    if cmd == 0x18:
        serial.write_buffer(CMD_FORWARD)
    elif cmd == 0x10:
        serial.write_buffer(CMD_LEFT)
    elif cmd == 0x38:
        serial.write_buffer(CMD_STOP)
    elif cmd == 0x5a:
        serial.write_buffer(CMD_RIGHT)
    elif cmd == 0x4a:
        serial.write_buffer(CMD_BACKWARD)

# 循环读取串口buffer数据
def on_forever():
    global data
    data = serial.read_buffer(4)
    if data[0] == 0xff:
        if data[1] == 0x01 and data[2] == 0x01:
            # 调用功能选择器函数
            switcher(data[3])
basic.forever(on_forever)

# 按下A按钮开始检测红外遥控器按键
def on_button_pressed_a():
    serial.write_buffer(CMD_START_IR)
input.on_button_pressed(Button.A, on_button_pressed_a)

# 按下B按钮停止检测红外遥控器按键
def on_button_pressed_b():
    serial.write_buffer(CMD_STOP_IR)
input.on_button_pressed(Button.B, on_button_pressed_b)

</code></pre>
<p>红外遥控器控制机器人跳舞，对机器人进行编程跳舞，有两种方式，一种是引入我们的koi扩展，koi扩展中对每一个舵机都设置有默认的一个编程工作，将这些动作进行相应的组合，可以做出不同的动作；第二种是直接对相应的舵机进行角度编程，这个需要多次调试才能的出最终的结果。以下代码是测试动作组</p>
<p><strong>koi编程动作组</strong></p>
<p>操作方法：按下A按钮初始化串口以及使用红外遥控器，按下play键机器人做动作，按下microbit的按钮B取消使能红外遥控器，按下A+B重新使能红外遥控器</p>
<pre><code class="language-python">'''
 自定义控制舵机角度编程动作组
 按下按钮A使能红外遥控器
 按下红外遥控器的播放键，机器人做出翘腿动作
 按下按钮B取消使能红外遥控器
 需要加载koi扩展，扩展地址：https://github.com/XiaoRGEEK/xrkoi
'''


def on_button_pressed_a():
    koi.init_serial(SerialPin.P1, SerialPin.P2)
    global running
    koi.enable_sensor(koi.Sensors.REMOTE)
    running = True

input.on_button_pressed(Button.A, on_button_pressed_a)

def anction():
    koi.set_sub_action1(koi.SubAction1.RST2LEFTSIDE)
    basic.pause(1000)
    for index in range(4):
        koi.set_sub_action3(koi.SubAction3.RST2LEFTBENT)
        basic.pause(500)
        koi.set_sub_action3(koi.SubAction3.LEFTBENT2RST)
        basic.pause(500)
    # 如果调用恢复角度没有成功的话，尝试调用koi.reset_all_action()来重置角度
    koi.set_sub_action1(koi.SubAction1.LEFTSIDE2RST)
    pause(1000)

# 按下按钮B停止检测红外遥控器
def on_button_pressed_b():
    global running
    koi.disable_sensor(koi.Sensors.REMOTE)
    running = False

input.on_button_pressed(Button.B, on_button_pressed_b)

running = False
basic.show_icon(IconNames.HAPPY)


def on_forever():
    if running:
        if koi.is_remote_btn_pressed(serial.read_buffer(4), koi.RemoteKey.PLAY):
            anction()


basic.forever(on_forever)
</code></pre>
<p><strong>自定义舵机角度进行动作组编辑</strong></p>
<p>操作方法：按下按钮A初始化串口以及使能红外遥控器，按下红外遥控器的play键，机器人做动作。按下microbit的B按钮，取消使能红外遥控器，按下A+B重新使能红外遥控器</p>
<pre><code class="language-python">&quot;&quot;&quot;
自定义控制舵机角度编程动作组
按下按钮A，使能红外遥控器
按下红外遥控器的播放键，机器人做出翘腿动作
按下按钮B，取消使能红外遥控器
需要加载koi扩展，扩展地址：https://github.com/XiaoRGEEK/xrkoi
&quot;&quot;&quot;

def on_button_pressed_a():
    koi.init_serial(SerialPin.P1, SerialPin.P2)
    global running
    koi.enable_sensor(koi.Sensors.REMOTE)
    running = True


input.on_button_pressed(Button.A, on_button_pressed_a)


def anction():
    koi.set_sub_action1(koi.SubAction1.RST2LEFTSIDE)
    pause(1000)
    value = 80
    # 丝滑的转到70°，不容易倒，参数10与机器人的安装方式以及电量有关，如果转到70°没有办法侧身站住
    # 那么可以尝试将数值调小，比如将range(10)，调成range(5)
    for i in range(10):
        value -= 1
        koi.set_servo_angle(4, value)
        pause(50)
    for index in range(4):
        koi.set_servo_angle(3, 120)
        pause(500)
        koi.set_servo_angle(3, 90)
        pause(500)
    koi.set_sub_action1(koi.SubAction1.LEFTSIDE2RST)
    pause(1000)


def on_button_pressed_b():
    global running
    koi.disable_sensor(koi.Sensors.REMOTE)
    running = False


input.on_button_pressed(Button.B, on_button_pressed_b)

running = False
basic.show_icon(IconNames.HAPPY)


def on_forever():
    if running:
        data = serial.read_buffer(4)
        if koi.is_remote_btn_pressed(data, koi.RemoteKey.PLAY):
            anction()


basic.forever(on_forever)
</code></pre>
<h2 id="第四章-超声波实验">第四章 超声波实验</h2>
<p><strong>准备：需要添加扩展sonar</strong></p>
<p>目的：通过检测超声波距离，来判断前方是否有障碍物，从而控制机器人做出相应的动作</p>
<p>原理：超声波的通讯原理，以及遇到障碍物的处理逻辑</p>
<p><strong>超声波跟随实验</strong></p>
<p>操作方法：按下microbit A按钮开始超声波检测，利用书本之类的遮挡超声波传感器，如果超声波距离大于20，则停止；如果距离小于20大于8，则前进；如果距离大于0小于8，则后退。按下按钮B可以停止超声波跟随功能</p>
<p>代码：</p>
<pre><code class="language-python">&quot;&quot;&quot;

需要加载microbit自带的sonar扩展

&quot;&quot;&quot;

# 按下A按钮开始超声波检测
def on_button_pressed_a():
    global running
    running = True


input.on_button_pressed(Button.A, on_button_pressed_a)

# 按下B按钮停止超声波检测
def on_button_pressed_b():
    global running
    running = False
    serial.write_buffer(CMD_STOP)
    basic.show_icon(IconNames.HAPPY)


input.on_button_pressed(Button.B, on_button_pressed_b)


distance = 0
running = False
basic.show_icon(IconNames.HAPPY)
CMD_FORWARD = Buffer.from_array([0xff, 0x02, 0x06, 0x00])
CMD_BACKWARD = Buffer.from_array([0xff, 0x02, 0x07, 0x00])
CMD_LEFT = Buffer.from_array([0xff, 0x02, 0x08, 0x00])
CMD_RIGHT = Buffer.from_array([0xff, 0x02, 0x09, 0x00])
CMD_STOP = Buffer.from_array([0xff, 0x02, 0x0a, 0x00])
# 重定向串口
serial.redirect(SerialPin.P1, SerialPin.P2, BaudRate.BAUD_RATE115200)
# 记录当前状态，用以过滤控制指令多次下发导致行进过程中，机器人抖动的问题
preState = &quot;&quot;
allDistance = 0
count = 0


def on_forever():
    global distance, allDistance, count, preState
    if running:
        # 读取超声波数据，滤波
        for i in range(30):
            distance = sonar.ping(
                DigitalPin.P13, DigitalPin.P14, PingUnit.CENTIMETERS)
            allDistance += distance
        distance = Math.ceil(allDistance / 30)
        allDistance = 0
        if distance &gt;= 20:
            if preState != &quot;STOP&quot;:
                preState = &quot;STOP&quot;
                serial.write_buffer(CMD_STOP)
        else:
            if distance &gt;= 8:
                if preState != &quot;GO&quot;:
                    preState = &quot;GO&quot;
                    serial.write_buffer(CMD_FORWARD)
            else:
                if distance &gt; 0:
                    if preState != &quot;BACK&quot;:
                        preState = &quot;BACK&quot;
                        serial.write_buffer(CMD_BACKWARD)


basic.forever(on_forever)

</code></pre>
<p><strong>超声波避障实验</strong></p>
<p>操作方法：按下A按钮，开始超声波距离检测，如果距离小于15，则机器人先后退1S，然后左转2.5s，最后直行；否则机器人前进</p>
<p>代码：</p>
<pre><code class="language-python">&quot;&quot;&quot;

需要加载扩展，扩展地址：https://github.com/XiaoRGEEK/xrkoi

&quot;&quot;&quot;

# 按下A按钮开始超声波检测
def on_button_pressed_a():
    global running
    running = True


input.on_button_pressed(Button.A, on_button_pressed_a)

# 按下B按钮停止超声波检测
def on_button_pressed_b():
    global running
    running = False
    serial.write_buffer(CMD_STOP)
    basic.show_icon(IconNames.HAPPY)


input.on_button_pressed(Button.B, on_button_pressed_b)

#记录当前状态，用以过滤控制指令多次下发导致行进过程中，机器人抖动的问题
preState = &quot;&quot;
distance = 0
running = False
basic.show_icon(IconNames.HAPPY)
CMD_FORWARD = Buffer.from_array([0xff, 0x02, 0x06, 0x00])
CMD_BACKWARD = Buffer.from_array([0xff, 0x02, 0x07, 0x00])
CMD_LEFT = Buffer.from_array([0xff, 0x02, 0x08, 0x00])
CMD_RIGHT = Buffer.from_array([0xff, 0x02, 0x09, 0x00])
CMD_STOP = Buffer.from_array([0xff, 0x02, 0x0a, 0x00])
# 重定向串口
serial.redirect(SerialPin.P1, SerialPin.P2, BaudRate.BAUD_RATE115200)


def on_forever():
    global distance, preState
    if running:
        # 读取超声波数据
        distance = koi.get_ultrasonic_distance(DigitalPin.P13, DigitalPin.P14)
        if distance &lt;= 15:
            basic.show_icon(IconNames.NO)
            if preState != &quot;STOP&quot;:
                preState = &quot;STOP&quot;
                serial.write_buffer(CMD_BACKWARD)  # 后退1s
                pause(1000)
                serial.write_buffer(CMD_LEFT)  # 向左转2.5s
                pause(2500)
                serial.write_buffer(CMD_FORWARD)  # 前进
        else:
            basic.show_icon(IconNames.YES)
            if preState != &quot;GO&quot;:
                preState = &quot;GO&quot;
                serial.write_buffer(CMD_FORWARD)
        pause(100)


basic.forever(on_forever)

</code></pre>
<h2 id="第五章-声音检测">第五章 声音检测</h2>
<p><strong>准备：使用该程序之前，需要导入Neopixel彩灯库扩展</strong></p>
<p>目的：通过声音传感器检测手掌是否拍下，从而控制RGB彩灯进行闪烁</p>
<p>原理：通过获取声音传感器的回传数据，并设置阈值，实现相应的结果。</p>
<p>操作方法：按下A按钮开始声音传感器检测，拍手机器人运动5s之后停止，按下B按钮可以取消声音传感器数据检测</p>
<p>代码：</p>
<p><strong>拍手控制机器人运动</strong></p>
<pre><code class="language-python">&quot;&quot;&quot;
按下按钮A使能声音传感器
拍手机器人做动作
按下按钮B取消使能声音传感器
注意：声音的阈值可以调整
&quot;&quot;&quot;
# 按下A按钮开始检测声音传感器
def on_button_pressed_a():
    serial.write_buffer(CMD_START_VOICE)
input.on_button_pressed(Button.A, on_button_pressed_a)

# 按下B按钮停止检测声音传感器
def on_button_pressed_b():
    serial.write_buffer(CMD_STOP_VOICE)
input.on_button_pressed(Button.B, on_button_pressed_b)

CMD_START_VOICE = bytes([0xff, 0x01, 0x02, 0x01])
CMD_STOP_VOICE = bytes([0xff, 0x01, 0x02, 0x00])
basic.show_icon(IconNames.HAPPY)
# 重定向串口
serial.redirect(SerialPin.P1, SerialPin.P2, BaudRate.BAUD_RATE115200)
# 循环读取数据
# 定义检测到声音的标志位
running = False
def on_forever():
    global running
    data = serial.read_buffer(4)
    if data[0] == 255:
        if data[1] == 2 and data[2] == 1:
            # 设置检测到的阈值小于0xb0的时候，作反应，该阈值可以调整
            if data[3] &lt;= 0xb0:
                running = True
basic.forever(on_forever)

# 循环检测声音标志位
def on_forever2():
    global running
    if running:
        running = False
        serial.write_buffer(Buffer.from_array([0xff, 0x02, 0x06, 0x00]))
        pause(5000)
        serial.write_buffer(Buffer.from_array([0xff, 0x02, 0x0a, 0x00]))
basic.forever(on_forever2)

</code></pre>
<p><strong>声控灯实验</strong></p>
<p>操作方法：操作方法如上一致</p>
<pre><code class="language-python">&quot;&quot;&quot;

需要加载neopixel彩灯扩展
按下按钮A使能声音传感器
拍手灯光闪
按下按钮B取消使能声音传感器
&quot;&quot;&quot;

# 按下A按钮开始检测声音传感器
def on_button_pressed_a():
    basic.show_icon(IconNames.HEART)
    serial.write_buffer(CMD_START_VOICE)


input.on_button_pressed(Button.A, on_button_pressed_a)

# 按下B按钮停止检测声音传感器
def on_button_pressed_b():
    basic.show_icon(IconNames.HAPPY)
    serial.write_buffer(CMD_STOP_VOICE)


input.on_button_pressed(Button.B, on_button_pressed_b)

data: Buffer = None
CMD_START_VOICE = bytes([0xff, 0x01, 0x02, 0x01])
CMD_STOP_VOICE = bytes([0xff, 0x01, 0x02, 0x00])
basic.show_icon(IconNames.HAPPY)
# 重定向串口
serial.redirect(SerialPin.P1, SerialPin.P2, BaudRate.BAUD_RATE115200)
strip = neopixel.create(DigitalPin.P16, 2, NeoPixelMode.RGB)

# 循环读取数据
def on_forever():
    global data
    data = serial.read_buffer(4)
    if data[0] == 255:
        if data[1] == 2 and data[2] == 1:
            # 如果声音响度阈值小于176, 0xb0
            if data[3] &lt;= 176:
                basic.show_icon(IconNames.SMALL_HEART)
                index = 0
                while index &lt;= 1:
                    # 一共只有2个彩灯
                    red = randint(0, 255)
                    green = randint(0, 255)
                    blue = randint(0, 255)
                    strip.set_pixel_color(
                        index, neopixel.rgb(red, green, blue))
                    strip.show()
                    index += 1
                    pause(100)
                pause(1000)
                basic.show_icon(IconNames.HEART)
    strip.clear()
    strip.show()


basic.forever(on_forever)

</code></pre>
<h2 id="第六章-图形识别">第六章 图形识别</h2>
<p><strong>准备：需要添加koi扩展</strong></p>
<p>目的：利用机器人的摄像头识别矩形以及圆形，并在LED点阵中显示识别到的内容</p>
<p>原理：按下Micro:bit按键A识别矩形，按键B识别圆形。当识别到，屏幕会在这个形状上标线框，Micro:bit同时返回对应的x坐标数值。</p>
<p>识别率视环境而定，如果有明显的形状却识别不到，请适当调整镜头距离并慢慢减小阈值直到精准识别为止。<strong>注意：阈值是调整识别率的重要参数：越小识别率越高，但抗干扰能力越低，经过测试圆形阈值为2000，矩形阈值为6000时识别效果较为友好</strong></p>
<p>代码：</p>
<p><strong>纯追踪矩形</strong></p>
<p>操作方法：按下按钮A开始识别矩形，按下按钮B取消识别矩形</p>
<pre><code class="language-python">'''
需要加载koi扩展，扩展地址：https://github.com/XiaoRGEEK/xrkoi
不同的机器人采用的阈值不同，这时需要修改阈值一般范围在6000-8000，具体情况需要具体调节koi.track_rect(6000-8000)
按下按钮A开始矩形识别
按下按钮B停止矩形识别
'''

# 按下A按钮初始化KOI串口并开始识别矩形
def on_button_pressed_a():
    koi.init_serial(SerialPin.P1, SerialPin.P2)
    koi.set_lcd_direction(koi.LcdDirection.FRONT)
    global running
    running = True

input.on_button_pressed(Button.A, on_button_pressed_a)

# 按下B停止按钮识别矩形
def on_button_pressed_b():
    global running
    running = False

input.on_button_pressed(Button.B, on_button_pressed_b)


def on_rect_track(x, y, w, h):
    global recoginze
    recoginze = True

koi.on_rect_track(on_rect_track)

recoginze = False
running = False
basic.show_icon(IconNames.HAPPY)


def on_forever():
    global recoginze
    if recoginze:
        recoginze = False
        koi.print(&quot;Rectangle&quot;, 0, 0)
        basic.show_leds(&quot;&quot;&quot;
            . . . . .
            # # # # #
            # . . . #
            # # # # #
            . . . . .
        &quot;&quot;&quot;)
    else:
        basic.show_icon(IconNames.HAPPY)

basic.forever(on_forever)

def on_forever2():
    if running:
        koi.track_rect(6000)

basic.forever(on_forever2)
</code></pre>
<p><strong>纯追踪圆形</strong></p>
<p>操作方法：按下按钮A开始圆形识别，按下按钮B取消圆形识别</p>
<pre><code class="language-python">&quot;&quot;&quot;
需要加载koi扩展，扩展地址：https://github.com/XiaoRGEEK/xrkoi
不同的机器人采用的阈值不同，这时需要修改阈值一般范围在6000-8000，
具体情况需要具体调节koi.track_rect(6000-8000)
按下按钮A开始圆形识别
按下按钮B停止圆形识别
&quot;&quot;&quot;

# 按下按钮A初始化KOI串口并开始识别矩形
def on_button_pressed_a():
    koi.init_serial(SerialPin.P1, SerialPin.P2)
    global running
    running = True


input.on_button_pressed(Button.A, on_button_pressed_a)

# 按下B停止识别圆形
def on_button_pressed_b():
    global running
    running = False

input.on_button_pressed(Button.B, on_button_pressed_b)


# 追踪圆形的结果回调函数
# 调用KOI扩展的圆形追踪回调函数
def on_circle_track(x, y, r):
    global recoginize
    recoginize = True

koi.on_circle_track(on_circle_track)

recoginize = False
running = False
basic.show_icon(IconNames.HAPPY)


def on_forever():
    global recoginize
    if recoginize:
        recoginize = False
        koi.print(&quot;Circle&quot;, 0, 0)
        basic.show_string(&quot;O&quot;)
    else:
        basic.show_icon(IconNames.HAPPY)

basic.forever(on_forever)


def on_forever2():
    if running:
        koi.track_circle(4000)

basic.forever(on_forever2)
</code></pre>
<h2 id="第七章-智慧出行实验">第七章 智慧出行实验</h2>
<p>目的：利用机器人的摄像头模块识别不同的颜色模块，模拟红绿灯，控制机器人做出相应的动作</p>
<p>代码：</p>
<p><strong>简单追踪色块实验</strong></p>
<p>操作方法：按下A按钮开始校准颜色，按下B按钮识别颜色</p>
<pre><code class="language-python">'''
需要加载koi扩展,扩展地址：https://github.com/XiaoRGEEK/xrkoi
烧录完程序之后，按下A按钮校准颜色，按下B按钮识别颜色
'''

# 按下按钮A开始校准颜色
def on_button_pressed_a():
    # 初始化串口
    koi.init_serial(SerialPin.P1, SerialPin.P2)
    pause(500)
    # 开始校准红色
    koi.color_calib(&quot;red&quot;)


input.on_button_pressed(Button.A, on_button_pressed_a)


def on_color_blob(x, y, w, h):
    global recognize, x1, y1
    recognize = True
    x1 = x
    y1 = y


koi.on_color_blob(on_color_blob)

# 按下按钮B开始识别颜色
def on_button_pressed_b():
    global running
    running = True


input.on_button_pressed(Button.B, on_button_pressed_b)

# 按下按钮AB停止识别颜色
def on_button_pressed_ab():
    global running
    running = False


input.on_button_pressed(Button.AB, on_button_pressed_ab)

# 开机显示笑脸
basic.show_icon(IconNames.HAPPY)
running = False
recognize = False
x1 = 0
y1 = 0


def on_forever2():
    global recognize
    if recognize:
        recognize = False
        koi.print(&quot;red,&quot; + &quot;(&quot; + str(x1) + &quot;,&quot; + str(y1) + &quot;)&quot;, 0, 0)
        basic.show_string(&quot;R&quot;)
    else:
        basic.show_icon(IconNames.HAPPY)


forever(on_forever2)


def on_forever():
    if running:
        koi.track_color_blob(&quot;red&quot;)


basic.forever(on_forever)

</code></pre>
<p><strong>智慧出行实验</strong></p>
<p>操作方法：按下A按钮校准三种颜色，按第一次，将摄像头对准红色色卡，校准红色，然后是绿色，最后是黄色；按下B按钮切换识别不同的颜色，机器人做出相应的动作；按下A+B按钮停止识别</p>
<pre><code class="language-python">'''
需要加载koi扩展,扩展地址：https://github.com/XiaoRGEEK/xrkoi
烧录该程序之后，首先需要按下A按钮校准三种颜色，按第一次，将摄像头对准红色色卡，校准红色，以此类推
按下B按钮切换识别不同的颜色，按第一次识别红色，一次类推；按下AB按钮取消颜色识别，并停止机器人
'''


def on_button_pressed_a():
    global label, num
    if num == 0:
        label = &quot;red&quot;
    elif num == 1:
        label = &quot;green&quot;
    elif num == 2:
        label = &quot;yellow&quot;

    koi.color_calib(label)
    num += 1
    if num &gt;= 3:
        num = 0


input.on_button_pressed(Button.A, on_button_pressed_a)


def on_color_blob(x, y, w, h):
    global feedback
    feedback = True
    koi.print(&quot;&quot; + label + &quot;-&quot; + (&quot;&quot; + str(x)) + &quot;-&quot; + (&quot;&quot; + str(y)), 0, 0)


koi.on_color_blob(on_color_blob)


# 按下AB按钮取消颜色追踪，并恢复tag值为0
def on_button_pressed_ab():
    global running, tag
    running = False
    tag -= 1
    if tag &lt; 0:
        tag = 0
    koi.control_robot(koi.Movement.STOP)
    basic.show_icon(IconNames.HAPPY)


input.on_button_pressed(Button.AB, on_button_pressed_ab)


def on_button_pressed_b():
    global running, label, tag, color
    # global tag
    running = True
    if tag == 0:
        label = &quot;red&quot;
        color = &quot;R&quot;
    elif tag == 1:
        # 模拟红灯
        label = &quot;green&quot;
        color = &quot;G&quot;
    elif tag == 2:
        # 模拟绿灯
        label = &quot;yellow&quot;
        color = &quot;Y&quot;
    # 模拟黄灯
    tag += 1
    if tag &gt; 3:
        tag = 0


input.on_button_pressed(Button.B, on_button_pressed_b)

tag = 0
running = False
feedback = False
label = &quot;&quot;
num = 0
color = &quot;&quot;
basic.show_icon(IconNames.HAPPY)
# 初始化串口，如果使用KOI.init_serial()函数,不能再这里写，可以编写A+B按钮按下初始化代码
serial.redirect(SerialPin.P1, SerialPin.P2, BaudRate.BAUD_RATE115200)


def on_forever():
    global feedback, label
    if feedback:
        feedback = False
        if label == &quot;red&quot;:
            # 红色
            koi.control_robot(koi.Movement.STOP)
        elif label == &quot;green&quot;:
            # 绿色
            koi.control_robot(koi.Movement.FORWARD)
        elif label == &quot;yellow&quot;:
            # 黄色
            koi.control_robot(koi.Movement.STOP)


basic.forever(on_forever)


def on_forever2():
    if running:
        koi.track_color_blob(label)
        basic.show_string(color)


basic.forever(on_forever2)

</code></pre>
<p><strong>根据色块做出不同的动作，注意：由于K210的限定，一次只能识别一种颜色，因此每次切换卡片的时候，需要按下按键B，按一次检测红色，按两次检测绿色，按三次检测黄色，循环往复</strong></p>
<h2 id="第八章-物体分类器实验">第八章 物体分类器实验</h2>
<p><strong>准备：需要加载koi扩展</strong></p>
<p>目的：学习图像分类原理，编程实现简单的物体分类，并在LED点阵中进行显示</p>
<p>原理：机器学习就是对图像特征提取，分析和比对，识别的准确率跟收集的模型数量有关，就像人类的记忆一样，多见几次的东西会印象深刻些。（<strong>KOI目前能够存储的数据量是40个，建议每个模型4张照片，即10个分类</strong>）</p>
<p>代码：</p>
<p><strong>直接加载我们提供好的模型文件</strong></p>
<p>操作步骤：按下A按钮加载模型，按下B按钮运行模型</p>
<pre><code class="language-python">'''
需要加载koi扩展，扩展地址：https://github.com/XiaoRGEEK/xrkoi
'''

# 默认存放模型文件路径
def on_button_pressed_a():
    koi.init_serial(SerialPin.P1, SerialPin.P2)
    pause(500)
    koi.cls_load(&quot;machine.json&quot;)


input.on_button_pressed(Button.A, on_button_pressed_a)

# 在LED点阵上显示识别出来的ID号，相关对应内容可以在下表中查找
def on_classified(classId):
    basic.show_string(classId)
    basic.show_icon(IconNames.HAPPY)


koi.classified(on_classified)


def on_button_pressed_b():
    koi.run()


input.on_button_pressed(Button.B, on_button_pressed_b)

basic.show_icon(IconNames.HAPPY)

</code></pre>
<p>定义：默认的模型类目如下：</p>
<table>
<thead>
<tr>
<th>模型名称</th>
<th>ID</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>person</td>
<td>0</td>
<td>人</td>
</tr>
<tr>
<td>cat</td>
<td>1</td>
<td>猫</td>
</tr>
<tr>
<td>dog</td>
<td>2</td>
<td>狗</td>
</tr>
<tr>
<td>bike</td>
<td>3</td>
<td>自行车</td>
</tr>
<tr>
<td>bird</td>
<td>4</td>
<td>鸟</td>
</tr>
<tr>
<td>boat</td>
<td>5</td>
<td>船</td>
</tr>
<tr>
<td>bus</td>
<td>6</td>
<td>公交车</td>
</tr>
<tr>
<td>sheep</td>
<td>7</td>
<td>绵羊</td>
</tr>
<tr>
<td>horse</td>
<td>8</td>
<td>马</td>
</tr>
<tr>
<td>cow</td>
<td>9</td>
<td>奶牛</td>
</tr>
</tbody>
</table>
<p><strong>自己录制模型</strong></p>
<p>操作方法：按下按钮A清除分类器，按下按钮B录制分类，每次录制四张图片，每录完一个物体，要录制下一个物体需要重新按下按钮B，最多只能录制10个物体；按下按钮A+B，保存分类。如果需要开始运行分类，<strong>烧录识别默认物体程序，注意：如果保存的分类结果名称需要一致，比如保存的是<code>machine.json</code>，在使用识别默认物体程序的时候，加载费分类模型也需要为<code>machine.json</code></strong></p>
<pre><code class="language-python">'''
 需要加载koi扩展，扩展地址：https://github.com/XiaoRGEEK/xrkoi
'''

def on_button_pressed_a():
    koi.init_serial(SerialPin.P1, SerialPin.P2)
    koi.reset_cls()


input.on_button_pressed(Button.A, on_button_pressed_a)


def on_button_pressed_ab():
    koi.cls_save(&quot;machine.json&quot;)


input.on_button_pressed(Button.AB, on_button_pressed_ab)

# koi.run()


def on_button_pressed_b():
    global num
    for index in range(4):
        koi.add_tag(&quot;id&quot; + (&quot;&quot; + str(num)))
    num += 1


input.on_button_pressed(Button.B, on_button_pressed_b)

num = 0
basic.show_icon(IconNames.HAPPY)
</code></pre>
<p>说明：本次的物体分类实验我们会提供10种分类模型的数据，存储在SD卡中，如果用户需要自己训练自己的机器识别模型，可以参照实例二的训练程序</p>
<p>注意：请确保KOI供电充足，以及SD卡加载成功的情况下使用，没有SD卡时不支持模型存储和加载，在KOI初次上电的情况下，可能会存在SD卡识别不到，是由于io电容充电较慢的原故，此时只需要给KOI重新上电即可</p>
<h2 id="第九章-人脸识别实验">第九章 人脸识别实验</h2>
<p>目的：学习人脸识别原理，编程实现人脸识别功能，并在LED点阵上显示</p>
<p>原理：由于人脸识别所依赖的条件太高，因此人脸辨认采用的是baiduAI的人脸识别库。所以如若需要使用该功能，首先需要先让KOI连上路由器外网，然后将人脸识别结果上传到baiduAI的人脸识别库，最后调用我们提供的方法，确定返回值即可。</p>
<ul>
<li>
<p>连接外网，可以使用如下代码测试wifi连接状况</p>
<pre><code class="language-python">'''
需要加载koi扩展，扩展地址：https://github.com/XiaoRGEEK/xrkoi
按下A按钮初始化koi串口，按下B按钮连接wifi，注意wifi名称和密码不要错，
按下A+B按钮，屏幕上显示的IP地址是0.0.0.0的话，机器人重启一下，然后再查看ip地址
如果ip地址不为0.0.0.0说明成功连上了网络，那么下一次开机之后会自动连接
wifi
'''

def on_button_pressed_a():
    koi.init_serial(SerialPin.P1, SerialPin.P2)
    koi.set_lcd_direction(koi.LcdDirection.FRONT)

input.on_button_pressed(Button.A, on_button_pressed_a)

def on_button_pressed_b():
    # 填入wifi热点的名称以及密码
    koi.join_ap(&quot;ssid&quot;, &quot;password&quot;)

input.on_button_pressed(Button.B, on_button_pressed_b)

def on_button_pressed_ab():
    # 获取IP地址
    koi.get_ip_addr()
input.on_button_pressed(Button.AB, on_button_pressed_ab)

basic.show_icon(IconNames.HAPPY)

</code></pre>
</li>
</ul>
<p>由于wifi具有记录功能，如果你的KOI已经确定连接过外网路由器了（通过获取wifi地址不为0.0.0.0可以验证是否入网），则可直接进入下一步无需重复入网</p>
<ul>
<li>
<p>了解人脸识别的流程</p>
<ol>
<li>识别并标定人脸：将识别到的人脸照片通过网络上传到baiduAI的服务器，根据你设定的名字添加到指定人脸组别</li>
<li>识别并辨认人脸：将识别到的人脸照片依然传到baiduAI服务器，由服务器在指定人脸组进行比对和处理并返回比对结果</li>
</ol>
</li>
<li>
<p><strong>程序的修改和下载，需要将组名和人名改成你自己的</strong></p>
</li>
<li>
<p>对准人脸按下microbit按键A，添加第一个人脸，按下按钮AB添加第二个人脸；<strong>人脸名称以及组别需要改成自己的</strong>。如果成功，屏幕上会有显示绿色的字体，如果失败的话，会显示红色的提示性语句</p>
<ul>
<li>接着对准人脸按下microbit按键B，如果在人脸识别库中找到相关的人脸信息，且可靠性大于60，则LED点阵显示√，否则x；另外屏幕上也会显示当前人脸的一些相关信息，比如年龄、性别等</li>
</ul>
</li>
</ul>
<p>代码：</p>
<pre><code class="language-python">&quot;&quot;&quot;
需要加载koi扩展，扩展地址：https://github.com/XiaoRGEEK/xrkoi
与连接外网分开进行烧录，烧录连接外网时已记住WiFi名称及密码;
另外需要注意的是本实验提供的组别以及人的名称仅作为参考，实际上使用的时候，
需要换成自己的组别以及人脸，不然太多人使用同一个组别以及人脸会导致人脸库爆满
&quot;&quot;&quot;

# 按下A按钮添加第一个人，名称为LH
def on_button_pressed_a():
    global flag
    flag = 0
    koi.cloud_face_recognize()


input.on_button_pressed(Button.A, on_button_pressed_a)

# 按下B按钮，在组别中查找人脸
def on_button_pressed_b():
    global flag
    flag = 1
    koi.cloud_face_recognize()


input.on_button_pressed(Button.B, on_button_pressed_b)

# 同时按下AB两个按钮，添加第二个人，名称为ABC


def on_button_pressed_ab():
    global flag
    flag = 2
    koi.cloud_face_recognize()


input.on_button_pressed(Button.AB, on_button_pressed_ab)


def on_cloud_reg_face(token, sex, age, mask, expression):
    if flag == 0:
        koi.cloud_face_add_group(token, &quot;kitten&quot;, &quot;LH&quot;)
    elif flag == 1:
        koi.cloud_face_search(token, &quot;kitten&quot;)  # 在组别中查找是否存在人脸数据
    elif flag == 2:
        koi.cloud_face_add_group(token, &quot;kitten&quot;, &quot;ABC&quot;)


koi.on_cloud_reg_face(on_cloud_reg_face)


def on_cloud_find_face(name, confidence):
    if name == &quot;LH&quot;:
        if confidence &gt;= 60:
            # 识别是这个人，且置信度大于60，认为识别正确
            basic.show_icon(IconNames.YES)
        else:
            basic.show_icon(IconNames.NO)
    # else:
    #     basic.show_icon(IconNames.NO)


# 云识别人脸
koi.on_cloud_find_face(on_cloud_find_face)


flag = 0
basic.show_icon(IconNames.HAPPY)
koi.init_serial(SerialPin.P1, SerialPin.P2)
basic.pause(3000)
# 填入你的wifi账号密码，如果之前已经连上过网，则此句可以省略
# koi.join_ap(&quot;ssid&quot;, &quot;password&quot;)

</code></pre>
<h2 id="第十章-智慧警卫实验">第十章 智慧警卫实验</h2>
<p>目的： 学习人脸追踪原理，介绍人脸追踪的应用案例，编程实现持续追踪人脸</p>
<p>原理：人脸追踪使用的是内置的YOLO模型，当检测到人脸特征值之后，LCD显示屏上会圈出相应的框，同时输出当前所在的人脸的x,y轴坐标系。使用我们提供的人脸追踪回调函数，可以检测摄像头识别的返回数据</p>
<p>代码：</p>
<p><strong>检测人脸并显示人脸数目</strong></p>
<p>操作方式：按下按钮A加载人脸模型，按下按钮B开始检测人脸，按下按钮AB获取检测到的人脸数量</p>
<pre><code class="language-python">'''
需要加载koi扩展，扩展地址：https://github.com/XiaoRGEEK/xrkoi
'''
# 按下A按钮初始化koi串口并加载YOLO人脸模型
def on_button_pressed_a():
    koi.init_serial(SerialPin.P1, SerialPin.P2)
    koi.load_yolo_face()
input.on_button_pressed(Button.A, on_button_pressed_a)

def on_find_face(x, y):
    koi.print(&quot;&quot; + str(x) + &quot;,&quot; + (&quot;&quot; + str(y)), 0, 0)
koi.on_find_face(on_find_face)

# 按下AB按钮获取检测到的人脸数量
def on_button_pressed_ab():
    basic.show_string(&quot;&quot; + str(koi.face_count()))
    basic.show_icon(IconNames.HEART)
input.on_button_pressed(Button.AB, on_button_pressed_ab)

# 按下B按钮检测人脸
def on_button_pressed_b():
    koi.face_detect()
    basic.show_icon(IconNames.YES)
input.on_button_pressed(Button.B, on_button_pressed_b)

# 开机显示笑脸表情
basic.show_icon(IconNames.HAPPY)
</code></pre>
<p><strong>智慧警卫实验</strong></p>
<p>操作方法：按下按钮A加载人脸模型，按下按钮B开始追踪人脸，追踪结果会在点阵上模拟显示，光点就代表人脸所在位置</p>
<pre><code class="language-python">'''
需要加载koi扩展，扩展地址：https://github.com/XiaoRGEEK/xrkoi
'''
def on_find_face(x, y):
    global x1, y1
    x1 = Math.map(x, 0, 239, 0, 4)
    y1 = Math.map(y, 0, 239, 0, 4)
koi.on_find_face(on_find_face)

y1 = 0
x1 = 0
running = False
basic.show_icon(IconNames.HAPPY)

def on_forever():
    if running:
        koi.face_detect()
        basic.clear_screen()
        led.plot(x1, y1)
basic.forever(on_forever)

# 按下按钮A初始化k210以及串口
def on_button_pressed_a():
    koi.init_serial(SerialPin.P1, SerialPin.P2)
    pause(500)
    koi.set_lcd_direction(koi.LcdDirection.FRONT)
    koi.load_yolo_face()
input.on_button_pressed(Button.A, on_button_pressed_a)

def on_button_pressed_b():
    global running
    running = True
input.on_button_pressed(Button.B, on_button_pressed_b)
</code></pre>
<h2 id="第十一章-智慧物流实验">第十一章 智慧物流实验</h2>
<p>目的：介绍视觉巡线方案以及物流工厂等领域的应用，编程实现机器人视觉巡线</p>
<p>操作方式：按下A按钮，开始录制巡线的线条，录制顺序为直行、左转、以及右转；录制完毕之后，按下B按钮，<br>
开始识别线条，识别到指定的内容之后，做相应动作5s，然后停止。</p>
<p><strong>注意：该程序是通过物体分类器实验设置的，因此一旦自行录制了模型之后，原先的物体分类器实验的识别默认物体将不可用，需要自己手动再次录制模型</strong></p>
<p>代码：</p>
<pre><code class="language-python">&quot;&quot;&quot;
需要加载koi扩展，扩展地址：https://github.com/XiaoRGEEK/xrkoi
操作方法：按下AB按钮，开始初始化k210物体分类器；按下A按钮，开始录制
巡线的线条，录制顺序为直行、左转、以及右转；录制完毕之后，按下B按钮，
开始识别线条，识别到指定的内容之后，做相应动作5s，然后停止。

注意：该程序是通过物体分类器实验设置的，因此一旦自行录制了模型之后，原先的
物体分类器实验的识别默认物体将不可用，需要自己手动再次录制模型
&quot;&quot;&quot;


def on_button_pressed_a():
    global num
    for index in range(4):
        koi.add_tag(&quot;id&quot; + (&quot;&quot; + str(num)))
    num += 1


input.on_button_pressed(Button.A, on_button_pressed_a)


def on_classified(classId):
    global myClassId, running
    myClassId = classId
    running = True

koi.classified(on_classified)


def on_button_pressed_ab():
    koi.init_serial(SerialPin.P1, SerialPin.P2)
    koi.reset_cls()


input.on_button_pressed(Button.AB, on_button_pressed_ab)

# koi.run()


def on_button_pressed_b():
    koi.run()


input.on_button_pressed(Button.B, on_button_pressed_b)

num = 0
myClassId = &quot;&quot;
running = False
basic.show_icon(IconNames.HAPPY)


def on_forever():
    global running, myClassId
    if running:
        running = False
        if myClassId == &quot;id0&quot;:
            basic.show_arrow(ArrowNames.NORTH)
            koi.control_robot(koi.Movement.FORWARD)
        elif myClassId == &quot;id1&quot;:
            basic.show_arrow(ArrowNames.EAST)
            koi.control_robot(koi.Movement.LEFT)
        elif myClassId == &quot;id2&quot;:
            basic.show_arrow(ArrowNames.WEST)
            koi.control_robot(koi.Movement.RIGHT)
        pause(5000)
        koi.control_robot(koi.Movement.STOP)
        myClassId = &quot;&quot;


basic.forever(on_forever)
</code></pre>
<h2 id="附录1-红外避障实验">附录1 红外避障实验</h2>
<p>目的：识别到障碍物之后发出警报障碍物消失之后，警报也随之消失，然后继续巡检</p>
<p>原理：当红外传感器检测到障碍物之后，pin8引脚会被置为高电平，否则会被置为低电平。我们可以通过判断引脚的高低电平状态实现我们需要的功能</p>
<p>代码：</p>
<p><strong>红外检测实验</strong></p>
<p>操作方法：按下按钮A使能红外传感器，按下按钮B取消使能红外传感器，如果检测到障碍物则LED点阵显示X，否则显示√</p>
<pre><code class="language-python">&quot;&quot;&quot;
需要加载koi扩展，扩展地址：https://github.com/XiaoRGEEK/xrkoi
按下按钮A使能红外传感器
按下按钮B取消使能红外传感器
&quot;&quot;&quot;
# 按下A按钮初始化koi串口并使能红外传感器
def on_button_pressed_a():
    global running
    koi.init_serial(SerialPin.P1, SerialPin.P2)
    koi.enable_sensor(koi.Sensors.IR)
    running = True

input.on_button_pressed(Button.A, on_button_pressed_a)


# 按下B按钮停止检测红外传感器数据上传
def on_button_pressed_b():
    global running
    koi.disable_sensor(koi.Sensors.IR)
    running = False
input.on_button_pressed(Button.B, on_button_pressed_b)

# 红外传感器电平状态
value = 0
# 启动红外传感器检测标志位
running = False
basic.show_icon(IconNames.HAPPY)
# 循环检测红外传感器是否遇到障碍物


def on_forever():
    global value
    if running:
        value = pins.digital_read_pin(DigitalPin.P8)
        # 如果遇到障碍物
        if value == 1:
            basic.show_icon(IconNames.NO)
        elif value == 0:
            basic.show_icon(IconNames.YES)


basic.forever(on_forever)

</code></pre>
<p><strong>红外巡检实验</strong></p>
<p>操作方法：按下A按钮初始化koi串口并开始红外传感器数据上传，按下B按钮取消红外传感器检测，如果需要重新检测红外传感器需要按下AB按钮；如果检测到障碍物，则彩灯闪烁不停，障碍物消失后，彩灯也随之消失，并且机器人前行</p>
<pre><code class="language-python">&quot;&quot;&quot;
需要加载koi扩展，扩展地址：https://github.com/XiaoRGEEK/xrkoi
需要彩灯扩展&quot;neopixel&quot;
在使用完之后，需要按下B按钮取消红外传感器检测，如果需要重新检测红外传感器
需要按下AB按钮
&quot;&quot;&quot;

# 使能红外传感器
def init_ir():
    global running
    koi.enable_sensor(koi.Sensors.IR)
    running = True
    koi.control_robot(koi.Movement.STOP)
    strip.clear()
    strip.show()

# 按下A按钮初始化koi串口并开始红外传感器数据上传
def on_button_pressed_a():
    koi.init_serial(SerialPin.P1, SerialPin.P2)
    init_ir()

input.on_button_pressed(Button.A, on_button_pressed_a)

# 按下AB按钮停止机器人，重新开始红外传感器数据检测
def on_button_pressed_ab():
    init_ir()

input.on_button_pressed(Button.AB, on_button_pressed_ab)

# 按下B按钮停止检测红外传感器数据上传，并退出红外传感器检测模式
def on_button_pressed_b():
    global running
    running = False
    strip.clear()
    strip.show()
    basic.show_icon(IconNames.HAPPY)
    koi.control_robot(koi.Movement.STOP)
    koi.disable_sensor(koi.Sensors.IR)

input.on_button_pressed(Button.B, on_button_pressed_b)


value = 0
running = False
strip: neopixel.Strip = None
basic.show_icon(IconNames.HAPPY)
strip = neopixel.create(DigitalPin.P16, 2, NeoPixelMode.RGB)
preState = &quot;&quot;

# 循环检测红外传感器是否遇到障碍物
def on_forever():
    global value, preState
    if running:
        value = pins.digital_read_pin(DigitalPin.P8)
        # 如果遇到障碍物
        if value == 1:
            basic.show_icon(IconNames.NO)
            preState = &quot;&quot;
            koi.control_robot(koi.Movement.STOP)
            for index in range(4):
                strip.show_color(neopixel.colors(NeoPixelColors.RED))
                strip.show()
                basic.pause(100)
                strip.show_color(neopixel.colors(NeoPixelColors.GREEN))
                strip.show()
                basic.pause(100)
        elif value == 0:
            basic.show_icon(IconNames.YES)
            if preState != &quot;go&quot;:
                preState = &quot;go&quot;
                koi.control_robot(koi.Movement.FORWARD)
            strip.clear()
            strip.show()
    else:
        strip.clear()
        strip.show()


basic.forever(on_forever)
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E6%B5%B7%E9%A3%8E%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%95%99%E7%A8%8B">海风机器人教程</a>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-microbit%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A6%82%E8%BF%B0">第一章 Microbit机器人概述</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E5%AE%9E%E9%AA%8C">第二章 机器人控制实验</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7%E5%AE%9E%E9%AA%8C">第三章 红外遥控实验</a></li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%B6%85%E5%A3%B0%E6%B3%A2%E5%AE%9E%E9%AA%8C">第四章 超声波实验</a></li>
<li><a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%A3%B0%E9%9F%B3%E6%A3%80%E6%B5%8B">第五章 声音检测</a></li>
<li><a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E8%AF%86%E5%88%AB">第六章 图形识别</a></li>
<li><a href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%99%BA%E6%85%A7%E5%87%BA%E8%A1%8C%E5%AE%9E%E9%AA%8C">第七章 智慧出行实验</a></li>
<li><a href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%89%A9%E4%BD%93%E5%88%86%E7%B1%BB%E5%99%A8%E5%AE%9E%E9%AA%8C">第八章 物体分类器实验</a></li>
<li><a href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%AE%9E%E9%AA%8C">第九章 人脸识别实验</a></li>
<li><a href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%99%BA%E6%85%A7%E8%AD%A6%E5%8D%AB%E5%AE%9E%E9%AA%8C">第十章 智慧警卫实验</a></li>
<li><a href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%99%BA%E6%85%A7%E7%89%A9%E6%B5%81%E5%AE%9E%E9%AA%8C">第十一章 智慧物流实验</a></li>
<li><a href="#%E9%99%84%E5%BD%951-%E7%BA%A2%E5%A4%96%E9%81%BF%E9%9A%9C%E5%AE%9E%E9%AA%8C">附录1 红外避障实验</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://ceoifung.github.io/rosdoc/post/hello-gridea/">
              <h3 class="post-title">
                Hello Gridea
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://ceoifung.github.io/rosdoc//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
